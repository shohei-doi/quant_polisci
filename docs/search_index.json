[["qualtrics.html", "第8章 Qualtricsデータの処理 8.1 Qualtricsのデータ 8.2 気合による方法 8.3 ループによる方法 8.4 tidyverseな方法 8.5 おまけ", " 第8章 Qualtricsデータの処理 Qualtricsはオンラインサーベイを便利に行うツールですが、政治学では特にサーベイ実験で使われていると思います。 qualtRicsのread_survey()を使いましょう！ サーベイ実験では被験者ごとに処理をランダムに与える必要があり、Qualtricsでは簡単にそれを行うことができるのですが、得られたデータを統計分析する際には一手間かかります。 ここでは、ロング・ワイドの変換で紹介したワイド形式からロング形式に変換する方法を応用してQualtricsのデータを統計分析用に整形する方法を説明します。 library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.1.2 ✓ dplyr 1.0.6 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() 8.1 Qualtricsのデータ ここではQualtricsから得られる架空のデータを使いたいと思います。 Qualtricsでは行は各被験者でユニークな識別番号の他に設問への回答が記載されています。 サーベイ実験ではグループごとに異なる設問がなされるため、例えば、グループが2つでグループ固有の設問が2種類、共通の設問が2種類の場合、以下のような形になっています。 data &lt;- tibble(id = c(1,2,3,4), y1_1 = c(2,3,NA,NA), y2_1 = c(1,4,NA,NA), y1_2 = c(NA,NA,5,3), y2_2 = c(NA,NA,6,4), x1 = c(2,3,3,6), x2 = c(6,4,1,1)) data 1, 2番目の被験者がグループ1で、3, 4番目の被験者がグループ2である。 便宜上、グループ1を統制群、グループ2を処置群とする。 グループ1の固有の設問の1つ目の回答がy1_1で2つ目の回答がy2_1である。 よってグループ1の被験者のy1_2とy2_2への回答は欠損値扱いになっている。 グループ2についても同様である。 全員共通の設問への回答はx1とx2である。 5件法の場合、「回答しない」は6番目の回答であることが多いため、被験者1はx2への、被験者3はy2_2への、被験者4はx1への回答を拒否したものとする。 このデータを統計的に分析するには以下のような形式になっていることが望ましいです。 tは処置群であれば1、統制群であれば0となるような変数である。 8.2 気合による方法 変数やグループの数が少ない場合は気合で書いてしまうという手もあります。 つまり、 統制群の応答変数y1_1とy2_1および共変量x1とx2を選択する。 応答変数の名前をy1とy2に共通化する。 応答変数が欠損しているサンプルは処置群なので除外する。 という方法です。 control &lt;- data[c(&quot;id&quot;, &quot;y1_1&quot;, &quot;y2_1&quot;, &quot;x1&quot;, &quot;x2&quot;)] names(control) &lt;- c(&quot;id&quot;, &quot;y1&quot;, &quot;y2&quot;, &quot;x1&quot;, &quot;x2&quot;) control &lt;- control[!is.na(control$y1) &amp; !is.na(control$y2),] control$t &lt;- 0 control control[!is.na(control$y1) &amp; !is.na(control$y2),]は「第1の応答変数が欠損していない」かつ「第2の応答変数が欠損していない」サンプルを指定しています。 同様の処理を処置群についても行います。 treatment &lt;- data[c(&quot;id&quot;, &quot;y1_2&quot;, &quot;y2_2&quot;, &quot;x1&quot;, &quot;x2&quot;)] names(treatment) &lt;- c(&quot;id&quot;, &quot;y1&quot;, &quot;y2&quot;, &quot;x1&quot;, &quot;x2&quot;) treatment &lt;- treatment[!is.na(treatment$y1) &amp; !is.na(treatment$y2),] treatment$t &lt;- 1 treatment 最後に、両者を結合し、6を欠損値に入れ替えます。 data_reshaped &lt;- bind_rows(control, treatment) data_reshaped[data_reshaped$y2 == 6,]$y2 &lt;- NA data_reshaped[data_reshaped$x1 == 6,]$x1 &lt;- NA data_reshaped[data_reshaped$x2 == 6,]$x2 &lt;- NA data_reshaped 8.3 ループによる方法 この方法はグループの数は多くなるとめんどくさくなるという欠点があります。 各グループについては同様の処理を行うので、forループによって簡略化することができます。 アイデアとしてはi回目の処理においてid共変量とy1_iとy2_iを抜き出します。 文字列はpaste0()という関数で結合することができます。 paste0(&quot;y1_&quot;, 1) ## [1] &quot;y1_1&quot; ちなみに、paste()は文字列の間に特定の記号を含める関数です。 paste(&quot;a&quot;, &quot;b&quot;, sep = &quot;/&quot;) ## [1] &quot;a/b&quot; つまり、paste0()はpaste(..., sep = \")のラッパー関数です。 さて、ここではiを1として選択する変数の名前をsel_varsというベクトルとして作成します。 i &lt;- 1 sel_vars &lt;- c(&quot;id&quot;, paste0(c(&quot;y1_&quot;, &quot;y2_&quot;), i), &quot;x1&quot;, &quot;x2&quot;) sel_vars ## [1] &quot;id&quot; &quot;y1_1&quot; &quot;y2_1&quot; &quot;x1&quot; &quot;x2&quot; 無事、必要な変数名を抜き出せています。 temp &lt;- data[sel_vars] temp その他の処理は先ほどと変わらないので、まとめると次のようになります。 data_reshaped &lt;- NULL for (i in 1:2) { sel_vars &lt;- c(&quot;id&quot;, paste0(c(&quot;y1_&quot;, &quot;y2_&quot;), i), &quot;x1&quot;, &quot;x2&quot;) temp &lt;- data[sel_vars] names(temp) &lt;- c(&quot;id&quot;, &quot;y1&quot;, &quot;y2&quot;, &quot;x1&quot;, &quot;x2&quot;) temp &lt;- temp[!is.na(temp$y1) &amp; !is.na(temp$y2),] temp$t &lt;- i - 1 data_reshaped &lt;- bind_rows(data_reshaped, temp) } data_reshaped[data_reshaped$y2 == 6,]$y2 &lt;- NA data_reshaped[data_reshaped$x1 == 6,]$x1 &lt;- NA data_reshaped[data_reshaped$x2 == 6,]$x2 &lt;- NA data_reshaped 処置変数はグループ番号から1を引いていますが本質的な問題ではありません。 8.4 tidyverseな方法 実はtidyverseのtidyrを応用するとこのような処理をすることができます。 まずは、応答変数に関してgather()でロングにします。 data_reshaped &lt;- data %&gt;% pivot_longer(-c(id, x1, x2), names_to = &quot;t&quot;, values_to = &quot;y&quot;) data_reshaped ポイントはこの段階で応答変数yが欠損値になっているのは、グループが異なる回答ということです。 グループ1の被験者にとってのy1_2とy2_2 グループ2の被験者にとってのy1_1とy2_1 なので、指定した変数が欠損値であるサンプルを除外する関数drop_na()でyが欠損しているサンプルを除外します。 data_reshaped &lt;- data_reshaped %&gt;% drop_na(y) data_reshaped 続いて、適当に名付けておいたtからグループの情報と応答変数の種類の情報を抜き出します。 str_extraxt()という関数は文字列からパターンに合致したものを抜き出します。 str_extract(&quot;y1_1&quot;, &quot;y[0-9]&quot;) ## [1] &quot;y1&quot; パターンのマッチングには正規表現というやや難しい表記が必要になります。 y[0-9]というのはyという文字と数字が1文字続く文字列という意味です。 str_extract(&quot;y1_1&quot;, &quot;_[0-9]&quot;) ## [1] &quot;_1&quot; 同様にしてグループの情報も抜き出せますが、_が邪魔です。 文字列から数値を抜き出す関数はparse_naumber()になります。 str_extract(&quot;y1_1&quot;, &quot;_[0-9]&quot;) %&gt;% parse_number() ## [1] 1 これでグループと応答変数の種類の情報を抜き出す準備が整いました。 以下ではtにグループ番号をkに応答変数の種類を入れる操作をします data_reshaped &lt;- data_reshaped %&gt;% mutate(k = str_extract(t, &quot;y[0-9]&quot;), t = str_extract(t, &quot;_[0-9]&quot;) %&gt;% parse_number()) data_reshaped 続いて、kの中身y1とy2を変数名に戻すためにspread()を使います。 data_reshaped &lt;- data_reshaped %&gt;% pivot_wider(names_from = &quot;k&quot;, values_from = &quot;y&quot;) data_reshaped 最後に欠損値をna_if()で代入しておきます。 data_reshaped &lt;- data_reshaped %&gt;% mutate(y2 = na_if(y2, 6), x1 = na_if(x1, 6), x2 = na_if(x2, 6)) data_reshaped 以上をパイプでまとめると次のようになります。 data_reshaped &lt;- data %&gt;% pivot_longer(-c(id, x1, x2), names_to = &quot;t&quot;, values_to = &quot;y&quot;) %&gt;% drop_na(y) %&gt;% mutate(k = str_extract(t, &quot;y[0-9]&quot;), t = str_extract(t, &quot;_[0-9]&quot;) %&gt;% parse_number()) %&gt;% pivot_wider(names_from = &quot;k&quot;, values_from = &quot;y&quot;) %&gt;% mutate(y2 = na_if(y2, 6), x1 = na_if(x1, 6), x2 = na_if(x2, 6)) data_reshaped ループを用いるか、tidyverseを用いるかにかかわらず重要なのは変数名の設定です。 応答変数と共変量をグループごとに定型的な変数名としておくことで処理が楽になります。 8.5 おまけ 5件法の場合、回答上では 賛成 やや賛成 どちらとも言えない やや反対 反対 となっていることが多いですが、分析上では 反対 やや反対 どちらとも言えない やや賛成 賛成 としたいのが人情です。 こういうときは、6（ないし5）から引いてあげればよいです。 data_reshaped %&gt;% mutate(y1 = 5 - y1, y2 = 5 - y2) "]]
