[
["index.html", "Rで計量政治学入門 はじめに 想定する読者 Tidyverseについて ウェブサイトの操作", " Rで計量政治学入門 土井 翔平 2020-04-21 はじめに 本書はRによる計量政治学の入門レベルの講義資料です。 質問や間違いなどがありましたら、ご連絡を下さい。 筆者のプロフィールはこちらをご覧ください。 想定する読者 本書は、データ分析や数学の前提知識やプログラミング経験のない社会科学系学部生を主たる読者として想定しています。 やや高度と思われる箇所には*を付けているので、読み飛ばしても構いません。 なお、RやRStudioのインストールについてはRの分析環境を、基本操作についてはRプログラミング入門をご覧ください。 Tidyverseについて Tidyverseとは様々なデータ操作に関するパッケージ群（あるいはそのプロジェクト）を指します。 本書では、可能な限り、Rの標準関数を用いた表記とTidyverseによる表記を併記するようにします。 しかし、筆者はTidyverseに慣れているので、しばしば標準関数によるコードを省略します。 ウェブサイトの操作 本書はbookdownを用いて作成しています。 ウェブサイトのナビゲーションバーでは、 三本線のボタンで目次の表示・非表示の切り替え 虫眼鏡のマークで単語検索 Aのマークで文字の大きさ、フォント、色のコントロール iのマークでキーボードによる操作方法の表示 が可能です。 "],
["data-import.html", "第1章 データの読み込み 1.1 パッケージ付属のデータ 1.2 主なデータ形式* 1.3 パスと作業ディレクトリ 1.4 .csvファイルの読み込み 1.5 .xls[x]ファイルの読み込み 1.6 .dtaファイルの読み込み 1.7 .rdsファイルの読み込み 1.8 パス入力の省略* 1.9 データの書き出し", " 第1章 データの読み込み 統計分析をする際にはデータを読み込む（インポート）必要があります。 基本的にPCに保存されたデータのパスを入力することでデータを読み込みます。 - URLを入力することでオンラインのデータを読み込むこともできます。 ここでは、まずRやパッケージに付属のデータセットの読み込み方を解説し、統計分析でよく使われるデータ形式を紹介した後に、Rによる読み込み方を説明します。 library(tidyverse) ## ── Attaching packages ──────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.0 ✓ purrr 0.3.4 ## ✓ tibble 3.0.0 ✓ dplyr 0.8.5 ## ✓ tidyr 1.0.2 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ── Conflicts ─────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() 1.1 パッケージ付属のデータ Rは標準でいくつかのデータセットを持っており、またパッケージを読み込むと付属のデータセットも読み込みます。 data()に何も入力せずに実行すると、データセットの一覧が表示されます。 data() よく、使われるデータセットはフィッシャーのアヤメのデータセットで、irisという名前で保存されています。 head(iris) head()は最初のいくつかの要素だけを表示する関数です（tail()は最後からいくつかを表示します）。 1.2 主なデータ形式* 大雑把に言ってしまうとPCのデータにはテキストデータとバイナリデータに分かれます。 さらにそれぞれ様々な種類の形式がありますが、拡張子によって判断します。 1.2.1 テキストデータ テキストデータとは人間の理解できる文字列のデータのことです。 1.2.1.1 .txtファイル .txtファイルは素のテキストデータになり、データの構造を含みません。 統計分析をする際には使いませんが、テキスト分析をする場合はしばしば遭遇します。 1.2.1.2 .csvファイル 統計分析で遭遇するテキストデータの大半は.csvファイルです。 これは“comma-separated values”の略で、各変数はカンマで区切られています。 各観察は改行で区切られています。 1.2.1.3 .tsvファイル .tsvファイルはカンマの代わりにタブで変数が区切られているテキストデータになります。 1.2.1.4 .htmlファイル .htmlファイルとはウェブサイトの内容を記述してあるファイルです。 ウェブスクレイピング（PCに自動でオンラインの情報を収集させること）をする際に使います。 1.2.2 バイナリデータ バイナリデータとはPCは理解できるけど人間は特定のソフトを使わないと理解できないようなデータになっています。 1.2.2.1 .xls, .xlsxファイル 最も有名なのはExcelで使用される.xlsまたは.xlsxファイルでしょう。 .xlsxの方が.xlsよりも新しくて高圧縮らしいです。 1.2.2.2 .dtaファイル .dtaファイルとはStataと呼ばれる統計分析ソフト専用のデータ形式になります。 Stataは政治学や経済学で人気のツールなのでレプリケーションデータなどはこの形式で配布されていることもあります。 1.2.2.3 .savファイル .savファイルはStataよりも前に人気だった統計ソフト用のデータ形式です。 1.2.2.4 .rdsファイル .rdsファイルとはR戦争のデータ形式になります。 あまり見かけることはありません。 1.2.3 Good bye, Excel! 基本的にはRでデータを読み込めば中身を見ることができるのですが、後述するようにRで読み込む前に生データを見たい場合はしばしばあります。 そのときにMicrosoft OfficeのExcelを使うのはあまりおすすめしません。 なぜなら、 Officeは高い 文字エンコードを指定できない からです。 特に後者の問題は重要だと思います。 例えば日本語を含むデータの場合、Windowsで作成されたものをLinuxやMacで開くと、あるいはその逆をすると文字化けを起こすからです。 そこで、LibreOfficeという無料のオフィスソフトをダウンロードし、その中のCalcを使用することをおすすめします。 LibreOffice Calcであればファイルを開く際にエンコードを選択できるので文字化けすることはありません。 Windowsで文字けする場合、エンコードをUTF-8にする。 Linux, Macで文字化けする場合、エンコードをShift-JISあるいはCP932にする。 もちろん、LibreOfficeでMicrosoft Officeのデータを開くことは可能です。 ただし、LibreOfficをインストールするとMicrosoft Officeが正常に動作しないことがあるかもしれません。 1.3 パスと作業ディレクトリ 一般的に、PCのデータはファイルと呼ばれ、ファイルを入れておく箱のようなものをフォルダ（ディレクトリ）と呼びます。 例えば、Windowsの場合、documentsやpicturesというフォルダがあり、その中にWordファイルや画像データが入っていると思います。 なお、ファイルの名前の末尾には.から始まる拡張子がついています。 例えば、Wordファイルであれば.docx、画像データであれば.pngや.jpgなどです。 これはそのファイルがどのような種類のもので、PCがどのように処理をすればいいのかを示す目印になっています。 - もし、PCで拡張子が表示されていない場合は表示するように設定しましょう。 1.3.1 パス ファイルやフォルダにアクセスする場合、パスと呼ばれるPC上の住所のようなもので指定する必要があります。 例えば、Windowsの場合、documentsフォルダの中のsample.docxというファイルのパスはC:/Users/Shohei/Documents/sample.docxとなります。 正確には、Windowsでは/ではなく円マークになっていると思います。 1.3.1.1 絶対パス このパスの意味はCドライブの中のUserというフォルダの中のShoheiというフォルダの中のDocumentsというフォルダの中にあるsample.docxという意味です。 このように始点（Windowsの場合はCドライブ）から始めるパスを絶対パスと呼びます。 1.3.1.2 相対パス しかし、毎回、絶対パスを書くのは面倒ですし、コードを公開する際にはやや恥ずかしい嫌いもあります。 そこで、途中から書かれるパスを相対パスと呼びます。 例えば、Shoheiというフォルダから見れば、上記のファイルはDocuments/sample.docxとして指定することができます。 1.3.1.3 パスに関する注意点 必ずしも直ちに問題があるわけではないですが、パスに日本語や空白があるとうまく行かないことがあります。 なので、フォルダ名やファイル名はアルファベットで空白を入れない方がいいでしょう。 もしユーザー名が日本語である場合、パス関連でエラーが出る場合はRStudio Cloudを使うか、これを機にOSをクリーンインストールをしてしまうのもありでしょう。 1.3.2 作業ディレクトリ 相対パスでファイルなどを指定する際には出発点となるフォルダを決める必要があります。 これを作業ディレクトリと呼びます。 Rではgetwd()（“get working directory”の略）で現在の作業ディレクトリを確認できます。 また、setwd()に適当なパスを入力することで作業ディレクトリを設定することもできます。 RStudioの場合はFilesパネルの中のMore &gt; Set As Working Directoryで現在開いているフォルダを作業ディレクトリに指定することもできます。 ただし、作業ディレクトリを指定するよりも、Rプロジェクトを作成するのがベターです。 1.4 .csvファイルの読み込み ここでは、例として世界銀行の各国の一人あたりGDPデータを読み込んでみます。 今回は適当に作成したプロジェクト・フォルダの中にdataというフォルダを作成し、その中にwb_gdp_pc.csvというデータを保存してください。 ここでは、tidyverseの中のreadrのread_csv()という関数を使います。 Rの標準関数はread.csv()です（_と.が違います）。 gdp_pc &lt;- read_csv(&quot;data/wb_gdp_pc.csv&quot;) ## Warning: Missing column names filled in: &#39;X3&#39; [3] ## Parsed with column specification: ## cols( ## `Data Source` = col_character(), ## `World Development Indicators` = col_character(), ## X3 = col_character() ## ) ## Warning: 265 parsing failures. ## row col expected actual file ## 2 -- 3 columns 64 columns &#39;data/wb_gdp_pc.csv&#39; ## 3 -- 3 columns 64 columns &#39;data/wb_gdp_pc.csv&#39; ## 4 -- 3 columns 64 columns &#39;data/wb_gdp_pc.csv&#39; ## 5 -- 3 columns 64 columns &#39;data/wb_gdp_pc.csv&#39; ## 6 -- 3 columns 64 columns &#39;data/wb_gdp_pc.csv&#39; ## ... ... ......... .......... .................... ## See problems(...) for more details. データを読み込む際には()の中に読み込みたいデータのパスを入力する必要があります。 したがって、プロジェクト・フォルダから見たデータの相対パスはdata/wb_gdp_pc.csvとなります。 パスをクオーテーションマーク&quot;で囲むことを忘れないでください。 パスの頭に/はいりません。 パスの最後に拡張子を付けることを忘れすに。 読み込んだデータもオブジェクトなので適当な名前をつけて代入する必要があります。 データの名前は 打ち込むのがめんどくさくない程度に短く 他人や数カ月後の自分が見ても分かる程度には意味の分かる ようにするのがコツです。 さて、データを無事読み込めるとEnvironmentパネルにgdp_pcが表示されていると思います。 1.4.1 変数名の適切な読み込み これで一安心と思いきや、Warningという不吉な文字列が見えます。 Environmentパネルをよく見ると変数の数が3つしかないということがわかります。 そこで、データを見てみると、なにかおかしいことが起こっているようです。 WarningとはErrorのように実行できないほどではないけれど、なんか問題があるかもしれない場合に表示されます。 Warningが出たときは問題がないのか確認しましょう。 head(gdp_pc) このような場合はLibreOffice Calcで元データを見てみましょう。 実はread_csv()ではデフォルトでは第1行目を変数名として読み込む設定になっています。 なので、元データのData SourceとWorld Development Indicatorsを変数名として認識してしまったようです。 では、なぜ三番目も変数として認識されているのかはよく分かりません。 変数名は第5行目なので、単純な方法は第1行目から第4行目を削除してしまうことですが、そうすべきではない理由がいくつかあります。 新しい年のデータを使うときに同じ操作をしないといけない。 同じ形式のデータを使うときに同じ操作をしないといけない。 第三者が元データからレプリケートするときに気付かないかもしれない。 ということで、第5行目からデータとして読み込めないか確かめるためにヘルプを見ます。 ?read_csv すると、このような記述が見つかります。 skip Number of lines to skip before reading data. ということで、オプションとしてskip=4を設定して読み込むとうまく行きました gdp_pc &lt;- read_csv(&quot;data/wb_gdp_pc.csv&quot;, skip=4) ## Warning: Missing column names filled in: &#39;X64&#39; [64] ## Parsed with column specification: ## cols( ## .default = col_double(), ## `Country Name` = col_character(), ## `Country Code` = col_character(), ## `Indicator Name` = col_character(), ## `Indicator Code` = col_character(), ## `2018` = col_logical(), ## X64 = col_logical() ## ) ## See spec(...) for full column specifications. head(gdp_pc) ちなみにNAとはRにおける欠損値 (missing value) のことです。 なお、実はこのように時間（この場合は年）が横方向に進んでいくデータをワイド形式と呼び、大抵の場合はこのままでは分析できないのでロング形式にする必要があります。 1.5 .xls[x]ファイルの読み込み 実はtidyverseはいくつかのパッケージをまとめたものになっています。 これまでテキストデータの読み込みに使っていたのは、その中のreadrというパッケージになります。 バイナリデータを読み込むには別途パッケージを使う必要があり、.xls[x]ファイルの場合は以下のものになります。 library(readxl) .xlsか.xslxか分かっている場合はread_xls()もしくはread_xlsx()の適切な方を使い、分からない場合はread_excel()を使います。 ここではFreedom Houseのデータセットを読み込みます。 fh &lt;- read_excel(&quot;data/FH_Country.xls&quot;) 1.5.1 シートの選択 Environmentパネルにfhがあるので一安心と思いきや、変数の数が1つと明らかにおかしいので、Rでデータを見て、LibreOffice Calcで開いてみます。 head(fh) すると、全くデータが異なっていることがわかります。 実はエクセルのデータにはシートという概念があり、異なるデータを一つにまとめることができます。 LibreOffice Calcの左下をよく見ると二番目のシートが選択されていることがわかります。 そしてその左の一番目のシートを選択するとRで読み込まれたものと同じものがあることがわかります。 つまり、先程は自動で一番目のシートを読み込んでしまっていたということで、オプションで二番目のシートを読み込まないといけないわけでした。 そこでヘルプを見るとsheetというオプションがあるので、sheet=2とするとちゃんとほしいデータを読み込んでくれます。 fh &lt;- read_excel(&quot;data/FH_Country.xls&quot;, sheet=2) ## New names: ## * `` -&gt; ...3 ## * `` -&gt; ...4 ## * `` -&gt; ...6 ## * `` -&gt; ...7 ## * `` -&gt; ...9 ## * ... head(fh) 1.5.2 変数名の適切な読み込み (again) これで一安心かと思いきや、そうではありません。 よくみると変数名が適切に選択されていないので、先ほどと同様にskipを設定する必要があります。 fh &lt;- read_excel(&quot;data/FH_Country.xls&quot;, sheet=2, skip=2) ## New names: ## * `` -&gt; ...1 ## * PR -&gt; PR...2 ## * CL -&gt; CL...3 ## * Status -&gt; Status...4 ## * PR -&gt; PR...5 ## * ... head(fh) 1.5.3 欠損値の処理 残念ながら問題はまだ残っています。 head()でデータの冒頭を見たときに変数名の下に&lt;chr&gt;とあるのに注目してください。 これは、当該変数が文字列 (character) であることを意味しています。 国名やステータスが文字列なのは当然として、本来数値データのはずのPR (political rights) やCL (civil liberty) も文字列データになっています。 元データを見てみると、ところどころ-という記号が含まれていることがわかります。 実はこれはFreedom Houseのデータセットにおける欠損値なのですが、Rではデフォルトでは空欄を欠損値として認識します。 そこで、やはりヘルプを見てnaを設定して-も欠損値として読み込むようにします。 fh &lt;- read_excel(&quot;data/FH_Country.xls&quot;, sheet=2, skip=2, na=&quot;-&quot;) ## New names: ## * `` -&gt; ...1 ## * PR -&gt; PR...2 ## * CL -&gt; CL...3 ## * Status -&gt; Status...4 ## * PR -&gt; PR...5 ## * ... head(fh) 実は文字列のままのPRやCLもあるのですが、そこはややこしいので今回は見なかったことにします。 1.6 .dtaファイルの読み込み .xls[x]ファイルと同様.dtaファイルもバイナリデータなので専用のパッケージを読み込みます。 library(haven) ここでは、Bruce Russett and John R. Oneal (2001) “Triangulating Peace” のレプリケーションデータ（とされるもの）を読み込みます。 triangle &lt;- read_dta(&quot;data/TRIANGLE.DTA&quot;) head(triangle) ハッピーなことにStataのデータはそもそも統計分析用に加工されているので、特に面倒くさい手続きをする必要はありません。 1.7 .rdsファイルの読み込み R専用のバイナリデータの形式は.rdsなので、write_rds()で書き出し、read_rds()で読み込むことができます。 1.8 パス入力の省略* データを読み込む際にいちいちパスを打ち込むのは面倒です。 そこで、右下のFilesパネルで読み込みたいデータをクリックするとImport Dataset...というのがあるのでクリックします。 すると次のような画面が出てきますが、右下にデータを読み込むためのパッケージ、関数、パスが表示されるので、関数とパスの部分をコピペしてしまうと楽です。 オブジェクト名の部分は自動的に決まるので、もとのデータの名前が長いとオブジェクト名も長くなり、かっこよくないので自分で設定するようにしたほうがよいでしょう。 また、データのプレビューも可能なのでここでskipなどの設定をすることも可能です。 1.9 データの書き出し データを書き出す際には、基本的に.csvファイルでよいと思うので、write_excel_csv()に保存したいオブジェクト名とパスを入れておきましょう。 ここでは試しにTriangulating Peaceのデータを保存してみます。 write_excel_csv(triangle, &quot;data/triangle.csv&quot;) 指定したパスに新しくファイルができていることを確認してください。 Triangulating Peaceデータの.csvファイルと.dtaファイルの容量を見ると.dtaファイルのほうが小さいことがわかります。 この程度では問題ありませんがデータがあまりにも大きくなる場合はバイナリデータで保存したほうがよいでしょう。 "],
["create-vars.html", "第2章 変数の作成 2.1 四則演算 2.2 条件に基づく変数 2.3 ラグ変数* 2.4 日付変数*", " 第2章 変数の作成 ここではTriangulating Peaceのレプリケーションデータを使用します。 library(tidyverse) data &lt;- read_csv(&quot;data/triangle.csv&quot;) ## Parsed with column specification: ## cols( ## statea = col_double(), ## stateb = col_double(), ## year = col_double(), ## dependa = col_double(), ## dependb = col_double(), ## demauta = col_double(), ## demautb = col_double(), ## allies = col_double(), ## dispute1 = col_double(), ## logdstab = col_double(), ## lcaprat2 = col_double(), ## smigoabi = col_double(), ## opena = col_double(), ## openb = col_double(), ## minrpwrs = col_double(), ## noncontg = col_double(), ## smldmat = col_double(), ## smldep = col_double(), ## dyadid = col_double() ## ) 2.1 四則演算 基本的にオブジェクトに$をつけて新しい変数名をつけて代入することで新しい変数を作成します。 例えば、A国とB国の民主主義度であるdemautaとdemautbの平均demautmを作成するには次のようにします。 data$demautm &lt;- (data$demauta + data$demautb)/2 head(select(data, demauta, demautb, demautm)) 四則演算は+（足し算）、-（引き算）、*（掛け算）、/（割り算）で行います。 他にも、%%（整数商）や^（累乗）もあります。 tidyverse表記の場合、dplyrのmutate()を使います。 この関数は第1引数にデータフレームを取り、その後ろに新しい変数の定義を書きます。 data &lt;- mutate(data, demautm = (demauta + demautb)/2) head(select(data, demauta, demautb, demautm)) 2.2 条件に基づく変数 ifelse()関数を使うと条件によって値の変わる変数を作成します。 例えば、smldepとはdependaとdependbの小さい方なので、これをmindepとすると次のように作成します。 data$mindep &lt;- ifelse(data$dependa &lt; data$demautb, data$dependa, data$dependb) head(select(data, dependa, dependb, smldep, mindep)) さて、if_else()は何をしているのでしょうか？ まず、第1引数は条件式となっています。 そして、その条件を満たす場合は第2引数を、満たさない場合は第3引数を出力します。 つまり、dependaがdependbよりも小さければdependaを、大きければdependbを返しています。 tidyverseの場合は、ほとんど同じですが、if_else()という関数を使います。 data &lt;- mutate(data, if_else(dependa &lt; demautb, dependa, dependb)) head(select(data, dependa, dependb, smldep, mindep)) tidyverseのcase_when()を使うと条件に応じて作る変数の値を2種類以上にすることができます。 例えば、1919年までをprewar、1920年から1945年をinterwar、1946年からをcoldwarとするような変数systemを作ります。 data &lt;- mutate(data, system = case_when(year &lt;= 1919 ~ &quot;prewar&quot;, year &gt; 1919 &amp; year &lt;= 1945 ~ &quot;interwar&quot;, year &gt; 1945 ~ &quot;coldwar&quot;)) 長くなるので、実行しませんが、table()によって、yearとsystemの対応関係をクロス表にできます. table(data$system, data$year) ## ## 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 ## coldwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## interwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## prewar 104 104 110 110 110 141 118 118 118 118 141 141 141 ## ## 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 ## coldwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## interwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## prewar 140 150 198 161 161 160 170 156 179 170 179 179 167 ## ## 1911 1912 1913 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 ## coldwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## interwar 0 0 0 265 275 235 242 243 401 373 388 457 465 ## prewar 162 171 172 0 0 0 0 0 0 0 0 0 0 ## ## 1930 1931 1932 1933 1934 1935 1936 1937 1938 1946 1947 1948 1949 ## coldwar 0 0 0 0 0 0 0 0 0 15 15 11 11 ## interwar 427 445 454 433 468 478 494 489 479 0 0 0 0 ## prewar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## ## 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 ## coldwar 343 336 331 337 338 363 373 393 400 399 540 599 633 ## interwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## prewar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## ## 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 ## coldwar 640 644 703 734 743 748 749 784 819 819 825 796 830 ## interwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## prewar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## ## 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 ## coldwar 850 824 820 800 836 829 850 851 861 849 865 857 855 ## interwar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## prewar 0 0 0 0 0 0 0 0 0 0 0 0 0 ## ## 1989 1990 1991 ## coldwar 802 649 567 ## interwar 0 0 0 ## prewar 0 0 0 ちなみに、mutate()の中では複数の変数を同時に作成することができます。 data &lt;- mutate(data, demautm = (demauta + demautb)/2, if_else(dependa &lt; demautb, dependa, dependb)) 2.3 ラグ変数* パネルデータの場合、ラグ変数（前の時点の変数）を作成することがあります。 tidyverseのdplyrにあるgroup_by()というグループ化する関数を使うとラグ変数を作成できます。 例えば、smldepのラグ変数をlag_smldepとして作成するとします。 このデータセットでは分析単位はダイアッドなので、cstateaとstatebでグループ化して変数を作ります。 lag()によって変数のラグを取ることができ、order_byでどの変数に関してラグを取るかを決めることができます。 data &lt;- data %&gt;% group_by(statea, stateb) %&gt;% mutate(lag_smldep = lag(smldep, order_by = year)) data %&gt;% select(statea, stateb, year, smldep, lag_smldep) %&gt;% head() lead()によってリードを取ることもできます。 2.4 日付変数* "],
["select-obs.html", "第3章 観察の選択 3.1 数値の大小による選択 3.2 一致・不一致による選択 3.3 「または」 3.4 「かつ」 3.5 部分集合 3.6 番号による選択 3.7 観察の並び替え 3.8 ベクトルの選択*", " 第3章 観察の選択 ここではTriangulating Peaceのレプリケーションデータを使用します。 library(tidyverse) data &lt;- read.csv(&quot;data/triangle.csv&quot;) 3.1 数値の大小による選択 R標準の方法ではdata[条件,]の条件部分に適当な論理値を入力して抜き出します。 例えば、1990年以降のデータだけを取り出す場合は以下のようにします。 head(data[data$year &gt;= 1990,]) なお、&gt;=の代わりに&gt;とすると1990年の観察は除外されます。 head(data[data$year &gt; 1990,]) 未満の場合は&lt;、以下の場合は&lt;=を使います。 tidyverseの中のdplyrというパッケージのfilter()という関数を使うともう少し簡単に書くことができます。 filter()はオブジェクトと条件式を入力すると条件に合致する観察を抜き出します。 head(filter(data, year &gt;= 1990)) data$変数名のように書かなくていいので楽です。 3.2 一致・不一致による選択 変数が特定の値に一致するときは==を使います。 例えば、1990年「のみ」の観察を抜き出すには次のようにします。 head(data[data$year == 1990,]) =ではない点に注意して下さい。 不一致の場合は!=を使います。 例えばstateaが2（アメリカ）でない観察を抜き出すには次のようにします。 head(data[data$statea != 2,]) 条件式の前に!を付けることで逆を表現することができます。 以下のコードは上記のコードと同じです。 head(data[!data$statea == 2,]) 3.3 「または」 複数の条件のいずれかに合致するものを抜き出すには|を使います。 例えば、stateaもしくはstatebが710（中国）である観察を抜き出す場合は次のようにします。 head(data[data$statea == 710 | data$stateb == 710,]) 3.4 「かつ」 複数の条件の全てに合致するものを抜き出すには&amp;を使います。 例えば、stateaが710でstatebが740（日本）である観察を抜き出す場合は次のようにします。 head(data[data$statea == 710 &amp; data$stateb == 740,]) 3.5 部分集合 yearが1950年から1990年までの10年刻みの観察を抜き出したいとします。 |を使うとこのようになります。 head(data[data$year == 1950 | data$year == 1960 | data$year == 1970 | data$year == 1980 | data$year == 1990,]) これではコードが長くなり面倒ですが、代わりに%in%を使うことができます。 %in%は左のベクトルで要素が右のベクトルの要素のどれかに一致するものを抜き出します head(data[data$year %in% c(1950, 1960, 1970, 1980, 1990),]) なお、等差数列を作る関数seq()を使うともっと簡単に書けます。 head(data[data$year %in% seq(1950, 1990, by = 10),]) tidyverseの場合はfilter()の中に複数の条件式を書いていきます。 3.6 番号による選択 特定の行だけを抜き出したい場合は、条件式の部分に当該番号を入力します。 例えば、最初の観察を抜き出すには次のようにします。 head(data[1,]) c()を使って複数行を選択することもできます。 head(data[c(1,3,5),]) nrow()はデータの行数を返す関数なので、一番下の観察を抜き出すには次のようにします。 head(data[nrow(data),]) -を付けるとその行を除外します。 head(data[-1,]) tidyverseで、行番号で指定する場合はslice()を使います。 head(slice(data, 1)) 3.7 観察の並び替え 変数の大きさによって並び替えをする場合、order()を使います。 例えば、年が古い順に並べる場合は次のようにします。 head(data[order(data$year),]) 逆に新しい順に並べる場合はオプションでdecreasing = TRUEとします。 head(data[order(data$year, decreasing = TRUE),]) tidyverseで観察を並び替える場合はarrange()を使います。 head(arrange(data, year)) 降順にする場合は変数名をdesc()で囲みます。 head(arrange(data, desc(year))) 複数の基準で並び替えることもできます。 head(arrange(data, desc(year), desc(dispute1))) 3.8 ベクトルの選択* なお、ベクトルは1行あるいは1列の行列と見ることができますが、Rでは行列とは区別されます。 ベクトルの要素にアクセスする場合は[]の中にアクセスしたい番号（のベクトル）を入れます。 例えば、lettersというアルファベットのベクトルを考えます。 letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 第1要素にアクセスする場合はこう書きます。 letters[1] ## [1] &quot;a&quot; 第1から第3要素までアクセスする場合はこう書きます。 letters[1:3] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 1:3は1から3まで1刻みに増えるベクトルを意味します。 データフレームからベクトルを抜き出す場合は$で変数を指定します。 head(data$year) ## [1] 1920 1921 1922 1923 1924 1925 tidyverseではpull()という関数を使います。 data %&gt;% pull(year) %&gt;% head() ## [1] 1920 1921 1922 1923 1924 1925 "],
["select-vars.html", "第4章 変数の選択 4.1 変数名による選択 4.2 番号による選択 4.3 変数名の変更 4.4 tidyverseな方法", " 第4章 変数の選択 ここではTriangulating Peaceのレプリケーションデータを使用します。 library(tidyverse) data &lt;- read.csv(&quot;data/triangle.csv&quot;) 4.1 変数名による選択 特定の変数をベクトルとして抜き出したい場合はオブジェクト名と変数名の間に$を入れます。 例えば、yearだけを抜き出したい場合は次のようにします。 head(data$year) ## [1] 1920 1921 1922 1923 1924 1925 データセットとして抜き出す場合は、オブジェクト名の後に[]をつけて、その中に変数名をクオーテーションマーク&quot;で囲んで入れます。 head(data[&quot;year&quot;]) 複数の変数を指定する場合はc()で変数名のベクトルを作って指定します。 例えば、stateaとstatebとyearを抜き出したい場合は次のようにします。 head(data[c(&quot;statea&quot;, &quot;stateb&quot;, &quot;year&quot;)]) 4.2 番号による選択 列番号を指定することで選択することもできます。 番号がひとつだけの場合はベクトルになります。 head(data[,3]) ## [1] 1920 1921 1922 1923 1924 1925 複数列を指定するとデータフレームとして抜き出します。 head(data[,c(1,2,3)]) -を付けるとその列を除外します。 head(data[,-3]) 4.3 変数名の変更 変数名を確認するにはnames()を使います。 names(data) ## [1] &quot;statea&quot; &quot;stateb&quot; &quot;year&quot; &quot;dependa&quot; &quot;dependb&quot; &quot;demauta&quot; ## [7] &quot;demautb&quot; &quot;allies&quot; &quot;dispute1&quot; &quot;logdstab&quot; &quot;lcaprat2&quot; &quot;smigoabi&quot; ## [13] &quot;opena&quot; &quot;openb&quot; &quot;minrpwrs&quot; &quot;noncontg&quot; &quot;smldmat&quot; &quot;smldep&quot; ## [19] &quot;dyadid&quot; names()に代入することで変数名を買えることができます。 例えば、stateaをStateAにするには次のようにします。 names(data)[1] &lt;- &quot;StateA&quot; names(data) ## [1] &quot;StateA&quot; &quot;stateb&quot; &quot;year&quot; &quot;dependa&quot; &quot;dependb&quot; &quot;demauta&quot; ## [7] &quot;demautb&quot; &quot;allies&quot; &quot;dispute1&quot; &quot;logdstab&quot; &quot;lcaprat2&quot; &quot;smigoabi&quot; ## [13] &quot;opena&quot; &quot;openb&quot; &quot;minrpwrs&quot; &quot;noncontg&quot; &quot;smldmat&quot; &quot;smldep&quot; ## [19] &quot;dyadid&quot; names()ベクトルなので第1要素を参照するには[1]とします。 あるいは、次のようにしてstatebをStateBにすることもできます。 names(data)[names(data) == &quot;stateb&quot;] &lt;- &quot;StateB&quot; names(data) ## [1] &quot;StateA&quot; &quot;StateB&quot; &quot;year&quot; &quot;dependa&quot; &quot;dependb&quot; &quot;demauta&quot; ## [7] &quot;demautb&quot; &quot;allies&quot; &quot;dispute1&quot; &quot;logdstab&quot; &quot;lcaprat2&quot; &quot;smigoabi&quot; ## [13] &quot;opena&quot; &quot;openb&quot; &quot;minrpwrs&quot; &quot;noncontg&quot; &quot;smldmat&quot; &quot;smldep&quot; ## [19] &quot;dyadid&quot; 4.4 tidyverseな方法 4.4.1 変数の選択 tidyverseのdplyrというパッケージではselect()によって変数の選択ができます。 例えば、StateA, StateB, yearを選択するには次のようにします。 head(select(data, StateA, StateB, year)) 変数を除外する場合は-をつけます。 head(select(data, -year)) 4.4.2 変数の並び替え selectでは変数の並び替えもできます。 head(select(data, year, StateA, StateB)) 変数の選択をせずに並び替えだけしたい場合は、並び替えた後にeverything()を入れます。 head(select(data, year, StateA, StateB, everything())) 4.4.3 変数名の変更 変数名を変える場合はselect()内部で=の左側に新しい変数名、右側にもとの変数名を書きます。 head(select(data, statea = StateA, stateb = StateB, year)) 変数名を変えるだけで変数の選択をしない場合はrename()を使います。 head(rename(data, statea = StateA, stateb = StateB)) "],
["data-combine.html", "第5章 データの結合", " 第5章 データの結合 "],
["reshape.html", "第6章 ロング・ワイドの変換", " 第6章 ロング・ワイドの変換 "],
["missing-values.html", "第7章 欠損値の処理", " 第7章 欠損値の処理 "],
["install-r.html", "第8章 Rの分析環境 8.1 Rのインストール 8.2 RStudioのインストール 8.3 再現可能な分析のために", " 第8章 Rの分析環境 Rは統計用のプログラミング言語です。 他に、特に機械学習の分野ではPythonやJuliaも人気です。 政治学や経済学ではStataという統計ソフトも人気ですが有料という難点があります。 また、RStudioはRを便利に使うための統合開発環境 (IDE) です。 RStudio以外にもあるもののデファクトスタンダードになっている感はあります。 RStudioはあくまでRを使いやすくするためのもので、R本体ではありません。 なので、まずはRをインストールしてからRStudioをインストールします。 8.1 Rのインストール 8.1.1 ダウンロード まずはRの公式サイトへ行き（右クリックで新しいタブで開くことができます）、download Rをクリックします。 次にダウンロードする際のミラーサイトを選びます。 好きな国のものを選んでいいですが、ここでは日本の統計数理研究所のものを選んでおきます。 自分のPCのOSに応じたものを選択します。 8.1.1.1 Windowsの場合 install R for the first timeを選択します。 Downlosd R X.X.X for YYYを選択してダウンロードします。 分かりやすいようにダウンロードフォルダにダウンロードしておきます。 Windowsの場合、Rtoolsをインストールもインストールしておきましょう。 8.1.1.2 Macintoshの場合 8.1.2 インストール Rをダウンロードしたフォルダを開き、ファイルをクリックします。 ファイル名はOSによって異なります。 その後は表示されるままに進めていけばよいです。 Rは基本的にOSの言語で表示されますが、英語で使いたい場合はMessage Translationsのインストールにチェックが入っている場合は外しておきましょう。 英語のエラーメッセージで検索したほうが解決策が見つけやすくなります。 8.2 RStudioのインストール 8.2.1 ダウンロード RStudioの公式サイトからRStudioのダウンロードサイトへ行きます。 下の方にインストーラーをダウンロードするリンクがあるのでOSに応じたものを選択します。 安定版ではないけれど最新のRStudioを使いたい人はRStudio Previewをインストールしてください。 また、RやRStudioをインストールせずにオンラインで使用できるRStudio Cloudというものもあります。 8.2.2 インストール あとはダウンロードしたフォルダに移り、インストーラーを起動して表示されるがままに進めていきます。 8.2.3 RStudioの起動 RStudioのショートカットをクリックしたり、メニューでRStudioと入力してクリックすると起動するはずです。 RStudioを初めて起動すると次のような表示になるとはずです。 左側の大きなパネルでRが表示されていればインストールの成功です。 ちなみに、Tools &gt; Global Options &gt; Appearanceではフォントや背景・ハイライトの色を変えることができます。 ダークな背景を選択するとRStudio全体もダークテーマになります。 8.2.4 RStudio Cloud* RStudio CLoudにより、RStudioをブラウザを使ってオンラインで使用することができます。 複数のユーザーで共同作業を行うことも可能です。 LinuxユーザーはRStudio Serverを使って自らサーバを立てることもできます。 8.3 再現可能な分析のために 再現可能性 (replicability) とは、狭義では、誰がどんな環境で分析しても。オリジナルの分析結果と（ほぼ）同じものを得られることだと思っています。 以下では、再現可能性を担保できるようなR/RStudioの使い方を解説します。 8.3.1 Rスクリプト まず、分析の手順を記録に残し、公開する必要があります。 RではRスクリプトと呼ばれるファイル（拡張子は.R）を作成し、そこにコードを残して起きます。 もちろん、使用したデータも公開する必要があるのは言うまでもありません。 8.3.1.1 Rスクリプトの作成 RStudioでは左上のFile &gt; New File &gt; RScriptもしくは白い紙に緑色のプラスマークのボタンを押してR Scriptを選択します。 すると、デフォルトでは左上のパネルにRスクリプトのエディタが表示されます。 8.3.1.2 Rスクリプトの展開 RスクリプトをRStudioで開くには左上のFile &gt; Open Fileで選択します。 8.3.1.3 Rスクリプトの実行 Rスクリプトに書かれたコードはCtrl + Enterを押すと、カーソルのある行がコンソールに流れ、実行されます。 8.3.2 Rプロジェクト データの読み込みで解説したように、データの読み込みや保存の際には起点となる作業ディレクトリ (working directory) を決める必要があります。 一般的に、作業ディレクトリはPCによって変わってしまうので、Rプロジェクトを立てることでその問題を回避します。 簡単に言えば、Rプロジェクトをクリックすることで自動的に作業ディレクトリが設定された状態でRStudioを起動することができます。 また、プロジェクトごとにRStudioを起動できるので、異なるプロジェクト間でデータやRスクリプトが混在することも回避できます。 ひとまず、新しい分析を行う際は必ずRプロジェクトを作成するようにしましょう。 8.3.2.1 Rプロジェクトの作成 まずは、プロジェクトの作り方ですが、RStudioの左上の青いボタンをクリックします。 続いて、新たにプロジェクト用のフォルダを作るのであればNew Directoryを、既存のフォルダをプロジェクト用にするのであればExisting Directoryを選択します。 基本的にはNew Projectを選択します。 最後に、プロジェクト用のフォルダの名前とそのフォルダを置くフォルダのパスを指定してCreate Projectをクリックします。 フォルダ名は必ず英数字と-や_で書き、日本語は避けましょう。 既存のフォルダを使う場合はパスを指定するだけです。 例えば今回はDocumentsフォルダの中にtestという名前のプロジェクトを作成しました。 一度、RStudioを終了し、先程指定したパス通りの場所にフォルダができていることを確認してください。 そのフォルダの中に、プロジェクト名と同じ名前の.Rprojファイルができているはずです。 8.3.2.2 プロジェクトの起動 それをダブルクリックしてみるとRStudioが起動されます。 このとき、すでに作業ディレクトリはプロジェクト用フォルダに指定されているのです。 getwd()で作業ディレクトリを確認してみて下さい。 8.3.2.3 ワークスペースの保存と再開* どうしても一度分析を中断して、再開したい場合はワークスペースを保存しておきましょう。 上記画面でSave workflow to .RData on exitがAskになっている場合、RStudioを終了する際にワークスペースを保存するのか聞かれるはずなので、保存します。 ちなみに、.RDataファイルはRのワークスペース（の一部）を保存するデータ形式です。 すると、フォルダ内に.RDataファイルができるので、再開するときにload()に当該ファイルのパスを入力して実行するとワークスペースが復元されます。 8.3.3 RStudioの設定* 8.3.3.1 RStudio起動時の挙動 Tools &gt; Global Optionsを開き、Genralの中で以下のチェックを外します。 平たく言うとRStudioを起動したときに前回の続きが残っていない真っさらな状態にしておきます。 8.3.3.2 文字コード 日本語がしばしば文字化けすることがあります。 なぜならWindowsではShift-JIS、LinuxとMacではUTF-8と呼ばれるエンコーディング（平たく言うとPCが文字を表示する方法）形式だからです。 詳しくはRにおける文字コードを参照して下さい。 UTF-8が世界的に使われているので、Code &gt; Saving &gt; Default text encodingをUTF-8にしておきます。 もし、日本語を含むファイルをRStudioで開いたときに文字化けしている場合、Windowsを使っている人はUTF-8のファイルをShift-JISで開いたということなので、File &gt; Reopen with EncodingでUTF-8を選択します。 逆にMacの場合はShift-JISのファイルをUTF-8で開いているので同様にShift-JISで開きます。 Windowsの人はUTF-8をデフォルトのエンコーディングにしてしまうといいでしょう。 "],
["intro-r.html", "第9章 Rプログラミング入門 9.1 関数 9.2 オブジェクト 9.3 パッケージ", " 第9章 Rプログラミング入門 Rによるプログラミングの基本として、 オブジェクト 関数 パッケージ について解説します。 大雑把に言えば、Rではオブジェクトとしてデータを読み込み、関数によってオブジェクト（＝データ）の処理や分析を行います。 パッケージによって様々な関数を追加することで、処理や分析の幅を広げます。 RStudioでは左（下）にコンソールが表示され、&gt;の右側にコマンドを打ち込み、Enterを押すことで実行されます。 本格的に分析する場合はRスクリプトを作成します。 9.1 関数 関数 (function) とは何かを入力すると、何かを出力するものです。 例えば、 print(&quot;Hello, World.&quot;) ## [1] &quot;Hello, World.&quot; というコードは、&quot;Hello, World.&quot;という文字列をprint()という関数に入力し、その文字列を出力しています。 Rでは、関数は関数名()という形を取ります。 入力するものを入力引数 (input argument) 、出力するものを出力引数 (output argument) と呼んだりします。 次のように、入力引数も出力引数も1つとは限りません。 rnorm(n = 10, mean = 0, sd = 1) ## [1] 0.06376889 0.07886507 -0.34029584 0.68719166 -0.52802340 1.06937509 ## [7] 0.67756020 -0.32816162 -1.12814660 -0.50736011 さて、この関数は何をしているのでしょうか。 Rでは、関数名の前に?をつけて実行することで、その関数のヘルプを見ることができます。 ?rnorm 英語で関数の使い方が解説されていますが、rnorm(n = 10, mean = 0, sd = 1)は平均0、標準偏差1の（標準）正規分布に従う乱数を10個だけ生じさせています。 入力引数は=で明示的に指定する場合、どのような順番でも構いません。 rnorm(mean = 0, sd = 1, n = 10) 入力引数を明示的に指定しない場合、ヘルプにある順番で入力します。 以下の例は上述のものと同じです。 rnorm(10, 0, 1) また、ヘルプでmean = 0, sd = 1のように書かれている場合、デフォルトが定められています。 実行者が入力引数を指定しない限り、デフォルト値が使用されます。 したがって、以下の例もこれまでと同じコードです。 rnorm(10) 9.1.1 総称関数* 総称関数 (generic function) とは、Rにおいて入力引数の種類に応じて挙動が変わる関数のことを指します。 例えば、summary()という関数はデータフレームが入力引数の場合には記述統計を表示しますが、回帰分析の結果の場合は回帰表を出力します。 総称関数のヘルプを見る場合は、以下のように、関数名に.をつけて入力引数の種類を書きます。 ?summary.data.frame ?summary.lm 9.2 オブジェクト Rでは&lt;-でオブジェクトを作成することができます。 例えば、20個の正規分布に従う乱数をxという名前のオブジェクトとして作成します。 x &lt;- rnorm(20) RStudioでは&lt;-はショートカットAlt + -で入力できます。 実際に、乱数がxに格納されていることが分かります。 x ## [1] 0.33773120 0.52462925 1.14846771 1.30060172 1.86298723 -1.27270085 ## [7] -0.08258518 -1.73199934 0.26094209 -1.88551717 0.32696352 1.08547839 ## [13] -0.49317022 0.76465812 0.45589260 -1.22680631 0.42016160 0.43759652 ## [19] -0.74594548 1.08483548 RStudioの場合、右上のEnvironmentパネルに生成されたオブジェクトが表示されます。 オブジェクトを入力引数とすることも可能です。 xの平均と標準偏差を求めてみます。 mean(x) ## [1] 0.128611 sd(x) ## [1] 1.0442 もちろん、出力引数を新しいオブジェクトにすることもできます。 x.mean &lt;- mean(x) x.mean ## [1] 0.128611 オブジェクトの名前にはアルファベットと数字、.と_が使えます。 ただし、数字は最初の文字としては使えません。 オブジェクトは上書きすることもできます。 x.mean &lt;- mean(rnorm(20)) x.mean ## [1] 0.318249 先ほどとは違う値に上書きされていることが分かります。 9.3 パッケージ 大雑把に言って、Rによるデータ分析はデータをオブジェクトとして読み込み、いろいろな関数で処理を行うことで実行します。 つまり、関数が重要なのですが、Rで標準に備わっている関数には限界があります。 そこで、様々な研究者が関数を作成し、それをまとめたものをパッケージとして公開しています。 基本的に、CRANでパッケージは公開されます。 ライブラリやモジュールと呼んだりすることもあります。 9.3.1 CRANからのインストール パッケージをインストールするには、install.packages()という関数にパッケージ名を入れて実行します。 試しに、Tidyverseという幅広く使われているパッケージをインストールしてみます。 install.packages(&quot;tidyverse&quot;) &quot;でパッケージ名を囲まないとエラーになります。 install.packages(tidyverse) ## Error in install.packages(tidyverse): object &#39;tidyverse&#39; not found RStudioの場合、Packagesパネル（デフォルトの場合は右下）の中にInstallというボタンがあり、 そこにパッケージ名を入力してインストールすることも可能です。 インストールしたパッケージに対して再びinstall.packages()を行うと、最新版にアップデートされます。 RStudioの場合、PackagesパネルにUpdateというボタンがあり、アップデートできるパッケージを自動検索してくれます。 9.3.2 GitHubからのインストール* パッケージの開発版や一部のパッケージはGitHub上で公開されています。 GitHub上のパッケージをインストールする場合はdevtoolsというパッケージを使うので、まずはインストールと読み込みを行います。 install.packages(&quot;devtools&quot;) library(devtools) インストールにはinstall_github()を使いますが、入力はパッケージ名ではなくユーザー名/レポジトリ名となる点に注意してください。 9.3.3 パッケージの読み込み パッケージはインストールしただけでは使用することはできず、library()で読み込む必要があります。 library(tidyverse) この場合は&quot;で囲む必要はありません。 インストールは一回で十分です。 RStudioであればPackagesパネルにインストール済みのパッケージ一覧があるので、パッケージ名をクリックすると含まれる関数一覧を見ることができます。 同様のものはCRANでもpdf形式で見ることができます。 一部のソフトウェアはJournal of Statistical Softwareなどで論文が公開されています。 9.3.4 tidyverseとは* Tidyverseとは広義にはRにおけるデータ処理を行うためのパッケージを開発するプロジェクトであり、狭義にはそこで開発されたパッケージの一部を指します。 具体的には、 ggplot2 dplyr tidyr readr purrr tibble stringr forcats になります。 パッケージとしてのtidyverseを読み込むことで、上記のパッケージを読み込んでいます。 なお、プロジェクト全体としては、上記のもの以外にも多くのパッケージが開発されています。 "],
["inter-r.html", "第10章 Rプログラミング応用* 10.1 オブジェクトのクラス 10.2 関数の作成 10.3 ループ 10.4 条件分岐 10.5 練習問題", " 第10章 Rプログラミング応用* Rによる、より高度な作業のために 代表的なオブジェクトのクラス オリジナルの関数の作成 ループや条件分岐 などを学びます。 10.1 オブジェクトのクラス オブジェクトの種類をクラスと呼びます。 class()にオブジェクトを入力するとクラスが分かります。 最も使われるのは数値 ()numeric, real) です。 class(1) ## [1] &quot;numeric&quot; 厳密には数値と整数 (integer) は異なりますが、気にしないといけない局面は少ないと思います。 class(2L) ## [1] &quot;integer&quot; 他には、文字列 (character) や class(&quot;Hello, World.&quot;) ## [1] &quot;character&quot; 論理値 (logical) などもあります。 class(TRUE) ## [1] &quot;logical&quot; 論理値は主に条件式が満たされるかどうかを示します。 1 == 1 ## [1] TRUE 0 &gt; 2 ## [1] FALSE ちなみに、TRUEは数値としての1、FALSEは0にもなります。 TRUE + 1 ## [1] 2 FALSE * 2 ## [1] 0 また、因子型 (factor) と呼ばれるクラスもあります。 カテゴリカル変数と言ったほうが分かりやすいかもしれません。 x &lt;- factor(1) x ## [1] 1 ## Levels: 1 class(x) ## [1] &quot;factor&quot; Xの中身は1ですが、数値ではなくカテゴリーになっているので、数値として操作することはできません。 x + 1 ## Warning in Ops.factor(x, 1): &#39;+&#39; not meaningful for factors ## [1] NA Rではベクトルには特別なクラスは付与されていません。 ベクトルはc()に中身を入力して作成します。 x &lt;- c(1,3,5) x ## [1] 1 3 5 行列 (matrix) はクラスとして存在します。 x &lt;- matrix(c(1,3,5,7), 2, 2) x ## [,1] [,2] ## [1,] 1 5 ## [2,] 3 7 class(x) ## [1] &quot;matrix&quot; 他に、データフレーム (data.frame) やリスト (list) などもあります。 クラスを確認するときは、is.*()の形をとる関数を使います。 is.numeric(1) ## [1] TRUE is.character(1) ## [1] FALSE クラスを変更するときは、as.*()のような関数を使います。 as.factor(1) ## [1] 1 ## Levels: 1 as.character(1) ## [1] &quot;1&quot; 必ずしも全てのクラスが任意のクラスに変換できるわけではありません（例えば、文字列から数値など）。 10.2 関数の作成 Rで関数を自作する際はfunction(){}という関数を使います。 ()の中に入力引数を記述します。 {}の中に処理内容を記述し、最後にreturn()で出力引数を指定します。 例えば、数値ベクトルを入力引数として、平均と標準偏差を出力引数とする関数を作成します。 mean_sd &lt;- function(x) { # 入力引数の名前をxとしておきます。 mean.x &lt;- mean(x) # 平均を計算します。 sd.x &lt;- sd(x) # 標準偏差を計算します。 return(c(mean.x, sd.x)) # 出力引数を指定します。 } 実際に実行してみます。 x &lt;- rnorm(100) mean_sd(x) ## [1] -0.02178397 0.95346976 10.3 ループ ループとは同一の処理を複数回実行することを指します。 例えば、100個の標準正規分布に従う乱数の平均を5回求める処理は次のようになります。 for (i in 1:5) { print(mean(rnorm(100))) } ## [1] -9.176324e-06 ## [1] 0.02650581 ## [1] -0.1938659 ## [1] -0.1239502 ## [1] -0.1104912 forループとは()の中のinのあとのベクトルの第1要素から順番にiに代入して繰り返しています。 そのことは、次の例から解ると思います。 head(letters) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; lettersとはアルファベットのベクトルです。 for (i in head(letters)) { print(i) } ## [1] &quot;a&quot; ## [1] &quot;b&quot; ## [1] &quot;c&quot; ## [1] &quot;d&quot; ## [1] &quot;e&quot; ## [1] &quot;f&quot; forループとは別に、特定の条件が満たされるまで繰り返されるwhileループもあります。 ループ処理の結果を格納するには少しテクニックが必要です。 100個の乱数の平均を5回取ったものをxとして保存したいとします。 まず、xをNULLオブジェクトとして作成します。 x &lt;- NULL x ## NULL NULLとは空っぽのオブジェクト（0という数値や空白という文字ではない）です。 先程のループ処理の中で、計算した平均をc()でxにくっつけていきます。 for (i in 1:5) { x &lt;- c(x, mean(rnorm(100))) } x ## [1] 0.04631948 0.09906966 0.03705817 -0.11361162 -0.15454222 無事、5個の平均値がxに保存されていることがわかります。 実際にforループの中で何が起こっているかは、次のコードで解ると思います。 x &lt;- NULL for (i in 1:5) { x &lt;- c(x, mean(rnorm(100))) print(x) } ## [1] -0.1033574 ## [1] -0.10335735 -0.04766531 ## [1] -0.10335735 -0.04766531 -0.02576042 ## [1] -0.10335735 -0.04766531 -0.02576042 -0.01483150 ## [1] -0.10335735 -0.04766531 -0.02576042 -0.01483150 -0.08468440 ループが一周するたびに、前回のxに新しい要素が付け加わり、新しいxとして保存されています。 NULLオブジェクトを使ったループ結果の保存でよくあるミスは、やり直す際にNULLでリセットするのを忘れることです。 例えば、同じコードをもう一度実行しましょう。 for (i in 1:5) { x &lt;- c(x, mean(rnorm(100))) } x ## [1] -0.1033573520 -0.0476653118 -0.0257604195 -0.0148315042 -0.0846844022 ## [6] -0.1843942629 -0.0003864674 0.0896376973 -0.0144994186 -0.1919437538 xに10個の平均値が入っています。 このようなミスを避ける方法の一つは、全体を関数として作成することです。 multi_mean &lt;- function() { x &lt;- NULL for (i in 1:5) { x &lt;- c(x, mean(rnorm(100))) } return(x) } x &lt;- multi_mean() x ## [1] 0.0289304806 -0.0274013245 0.0016569497 0.0006372139 -0.0212061454 10.4 条件分岐 条件分岐とは、特定の条件の場合に特定の動作を行うようにすることです。 例えば、正の場合positive、負の場合negativeと出力するコマンドは次のようになります。 x &lt;- rnorm(1) if (x &gt; 0) { print(&quot;positive&quot;) } else { print(&quot;negative&quot;) } ## [1] &quot;negative&quot; print(x) ## [1] -1.204067 if(){}の()の中に条件式を書き、{}の中に処理内容を書きます。 それ以外の条件はelseで示します。 条件式は3つ以上でも構いません。 x &lt;- rnorm(1) if (x &gt; -0.5) { print(&quot;x is less than -0.5.&quot;) } else if (x &gt;= -0.5 &amp; x &lt;= 0.5) { print(&quot;x is between -0.5 and 0.5.&quot;) } else { print(&quot;x is more than 0.5.ー&quot;) } ## [1] &quot;x is more than 0.5.ー&quot; print(x) ## [1] -1.320844 &amp;は「かつ」を意味します。 「または」は|を使います。 &gt;=は \\(\\geq\\) を意味します。 「同じ値である」は==を使います（=ではない点に注意）。 10.5 練習問題 10.5.1 フィボナッチ数列 フィボナッチ数列とは以下の条件を満たす数列です。 \\[ \\begin{aligned} F_0 &amp;= 0 \\\\ F_1 &amp;= 1 \\\\ F_{n} &amp;= F_{n-1} + F_{n-2} \\quad n \\geq 2 \\end{aligned} \\] 例えば、 \\[ \\begin{aligned} F_2 = 1, F_3 = 2, F_4 = 3, F_5 = 5, F_6 = 8,\\ldots \\end{aligned} \\] となります。 フィボナッチ数列の第\\(n\\)項を（解析解を使わずに）求める関数を作成してみて下さい。 また、\\(F_n \\geq m\\)となるような\\(n\\)を求める関数を作成してみて下さい。 10.5.2 モンテカルロ・シミュレーション モンテカルロ・シミュレーション（モンテカルロ法）とは乱数を用いて近似解を求める手法です。 例えば、円周率\\(\\pi\\)の近似解は以下のように求めることができます。 0以上1未満の一様分布から\\(n\\)個の乱数\\(x_i\\)と\\(n\\)個の乱数\\(y_i\\)を発生させます (\\(i = 1,2,\\ldots,n\\)) 。 原点と\\((x_i,y_i)\\)の距離が1以下である回数を計算し\\(n_1\\)とします。 円周率の近似解として\\(\\hat{\\pi} = 4 \\times n_1/n\\)を得ます。 モンテカルロ・シミュレーションによる円周率の近似解を求める関数を作成してみて下さい。 また、モンテカルロ・シミュレーションによる円周率の近似解を\\(m\\)回求めて、その平均値や標準偏差が\\(n\\)によってどのように変化するか検討してみて下さい。 "],
["r-makdown.html", "第11章 R Markdown入門 11.1 R Markdownファイルの作成 11.2 Markdown記法 11.3 Rチャンク 11.4 yamlヘッダー 11.5 その他のテンプレート", " 第11章 R Markdown入門 データ分析の再現可能性の必要性は論を俟たないですが、再現可能性を担保するにはレプリケーションデータやコードを公開するだけでなく、それらが理解可能である必要があります。 恐ろしいことに自分が書いたコードでさえ数カ月後に読み返すと意味がわからないことはまれによくあります。 Rスクリプトに#でコメントするのが単純な方法ですが、データ分析においてはしばしば文章とコード、アウトプットを混在させたノートブックを使用することがあります。 詳しくはないですが文芸的プラグラミングと呼ばれるものの一種のような気がします。 更にノートブックからより見やすいファイルを作成することができ、そのファイルおよびシステムをR Markdownと呼びます。 実は、と言うほどではないですが、このブログもR Markdownで書かれています。 11.1 R Markdownファイルの作成 百聞は一見に如かずなので、一まずはR Markdownを使ってみます。 まず、左上のファイルを作成するボタンを押し、R Markdown...を選択します。 初めてR Markdownを使う場合は必要なパッケージをインストールするか聞かれるのでインストールを選択します。 続いて、どのような種類のR Markdownファイルを作成するかを選択するので、（デフォルトのままですが）DocumentのHTMLを選択します。 すると、エディタに以下のようなサンプルのRmdファイルが表示されます。 適当なフォルダに保存し、エディタ上部のKnitをクリックするかShift + Ctrl + kを押すとR Markdownファイルがタイプセットされます。 無事、タイプセットに成功すると以下のような.htmlファイルのプレビューが表示されます。 .Rmdファイルを保存したフォルダに.htmlファイルが生成されているはずです。 .htmlファイルとはウェブサイトを作成するためのファイルで、ウェブブラウザ（例、FirefoxやGoogle Chrome）で開くことできれいに見れます。 11.1.1 参考になるサイト R Markdownの公式サイト R Markdown: The Definitive Guide R Markdownのチートシート (pdf) 比治山大学の前田和寛先生のR Markdown入門 11.2 Markdown記法 11.2.1 Markdownとは* R MarkdownとはMarkdownとRスクリプトを合体させたようなものです。 ここではMarkdownについて説明しますが、読み飛ばしても構いません。 Markdownとは計量マークアップ言語と呼ばれているようにマークアップ言語の一種です。 マークアップ言語とは文章の中身と役割・外見を区別して記述する言語です。 逆に、世間で普及しているWordのように文章の中身と役割・外見が混在しているエディターはWYSIWYGと呼びます。 例えば、Wordではセクションの名前などは指定することができますが、見た目はフォントのサイズが大きくなったり、太字になったりします。 一方で、マークアップ言語の一種である.htmlファイルでは &lt;h1&gt;セクションタイトル&lt;/h1&gt; のように明示的にh1というタグをつけ、h1タグのついている文章に対して.cssファイルで見た目を決定します。 同様に、LaTeXでは\\section{セクションタイトル}のようにタグをつけます。 基本的にはWYSIWYGなソフトのほうが直観的な操作が可能で作業が楽ではあるものの、マークアップ言語はテキストで役割や外見も決めるので再現可能性が高いと言えるでしょう。 そこで、より簡便なマークアップ言語として登場したのがMarkdown記法です。 なので、HTML記法を使うこともできます。 11.2.2 セクション Markdownでは#を使ってセクションのタイトルを記述します。 #が多くなればなるほどより小さな見出しになります。 # レベル1 ## レベル2 ### レベル3 #### レベル4 11.2.3 パラグラフ 空行を入れると新しいパラグラフになります。 同じパラグラフです。 同じパラグラフです。 同じパラグラフです。 同じパラグラフです。 違うパラグラフです。 違うパラグラフです。 違うパラグラフです。 違うパラグラフです。 なので、パラグラフ内でも一文ごとに改行したほうが見やすいと思います。 11.2.4 箇条書き 番号なしの箇条書きの場合は=を、番号付きの箇条書きの場合は1.を入れます。 - 番号なし箇条書き - 番号なし箇条書き - 番号なし箇条書き 番号なし箇条書き 番号なし箇条書き 番号なし箇条書き 1. 番号付き箇条書き 1. 番号付き箇条書き 1. 番号付き箇条書き 番号付き箇条書き 番号付き箇条書き 番号付き箇条書き タブ（半角スペース4つ分）を入れると階層構造をつけることができます。 - レベル1 - レベル2 - レベル１ レベル1 レベル2 レベル１ 11.2.5 文字の強調 *もしくは_で囲むと斜体になり、**もしくは__で囲むと太字になります。 *斜体*と**太字** 斜体と太字 ｀で囲むとコードになり、~~で囲むと打ち消されます。 `code`と~~打ち消し~~ codeと打ち消し 日本語のLaTeXでは打ち消しに対応していないので、表示させていません。 11.2.6 引用 &gt;から始めると引用になります。 &gt; 引用文です。 引用文です。 11.2.7 リンク リンクを貼る場合は[リンク名](リンク先のURL)あるいは&lt;リンク先のURL&gt;とします。 - [RStudio](https://www.rstudio.com/) - &lt;https://www.rstudio.com/&gt; RStudio https://www.rstudio.com/ 11.2.8 画像、表 画像を埋め込む場合は![画像名](画像のパス)とします。 ![Rlogo](figures/Rlogo.png) Rlogo 表を埋め込む際には次のように書きます。 | 項目1 | 項目2 | 項目3 | |-------|-------|-------| | りんご| 100 | 赤 | | みかん| 80 | オレンジ | 項目1 項目2 項目3 りんご 100 赤 みかん 80 オレンジ 11.2.9 数式 LaTeX記法による数式を記述できます。 インラインの場合は$で囲み、ディスプレイの場合は$$で囲みます。 .htmlの場合、mathjaxによって数式を表示するのでオフラインでは表示できません。 確率変数$X_i$は平均$\\mu$、分散$\\sigma^2$の正規分布に従う。 確率変数\\(X_i\\)は平均\\(\\mu\\)、分散\\(\\sigma^2\\)の正規分布に従う。 $$ X_i \\sim \\mathcal{N}(\\mu,\\sigma^2) $$ \\[ X_i \\sim \\mathcal{N}(\\mu,\\sigma^2) \\] 11.3 Rチャンク R Markdown内でRコードを記述する際にはRチャンクと呼ばれるものの中で行います。 Rチャンクは次のような形をしています。 Ctrl + Alt + IでRチャンクを挿入することができます。 まず、この部分は後述するチャンクオプションを指定する場所になります。 ここではRコードであること、チャンク名をcarsと指定しています。 R MrkdownにおいてもRスクリプトと同様にCtrl + Enterでコードを実行することができます。 あるいはRチャンクの右上のボタンをクリックしても実行できます。 実行されたコードはチャンクの直下に表示されます。 右上から二番目のボタンはこのRチャンクの直前のRチャンクまでのコードを全て実行するボタンになります。 11.3.1 チャンクオプション チャンクオプションを指定することでコードとそのアウトプットをどのように出力するかを制御することができます。 主なものをまとめておきます。 eval=FALSEとするとコードは表示されるが実行されない。 echo=FALSEとするとコードは実行されるが表示されない。 include=FALSEとするとコードは実行されるがコードも実行結果も表示されない。 warning=FALSEやerror=FALSE、message=FALSEとすると警告やエラー、メッセージが表示されない。 例えば、{r, echo=FALSE}のように書きます。 デフォルトを変更したい場合は冒頭でknitr::opts_chunk$set(echo=TRUE)のように設定します。 11.4 yamlヘッダー yamlヘッダーとは.Rmdファイルの冒頭で---によって囲まれた箇所で、ページ全体の設定を行います。 初期状態では --- title: &quot;Untitled&quot; author: &quot;Shohei Doi&quot; date: &quot;4/9/2019&quot; output: html_document --- となっていますが、titleやauthor、dateでタイトル、著者、日付を設定できます。 11.4.1 output outputによって出力形式を決定します。 これによってyamlヘッダーにおいてどのような項目を設定できるのかも決まります。 どのような出力形式が利用可能であるかは後述するとして、以下ではhtml_documentにおける主なyamlヘッダーの設定を紹介します。 前田先生のページが参考になります。 11.4.2 目次 目次を出力するには次のように書きます。 output: html_document: toc: TRUE 目次の設定には次のようなものがあります。 output: html_document: toc: TRUE toc_depth: 2 toc_gloat: TRUE number_sections: TRUE toc_depthによってどの階層の見出しまで表示するかを決めます。 toc_floatをTRUEにすると目次がスクロールしてもついてきます。 number_sectionsをTRUEにすると見出しに通し番号がつきます。 11.4.3 テーマ テーマを決める場合はthemeで指定します。 テーマ一覧はこちらになります。 output: html_document: theme: &quot;paper&quot; 11.4.4 htmlとcss cssによってカスタム.cssファイルを指定できます。 includeによって.htmlファイルの挿入ができます。 デフォルトでは.cssファイルは画像データなどは全て.htmlファイルに含まれてスタンドアロンな形で見ることができます。 しかし、self_containedをFALSEとすると付属ファイルは別フォルダに作成され、.htmlファイル自体が見やすくなります。 11.5 その他のテンプレート outputを変更することで、いくつかのテンプレートを使用することができます。 ここでは.htmlファイルが出力されるいくつかのテンプレートを紹介しておきます。 公式サイトのGalleryやFormatsをご覧ください。 11.5.1 Distill Distillはウェブで公開することを念頭に置いた専門的な記事を書くためのテンプレートになっています。 インストールは以下のように行います。 devtools::install_github(&quot;rstudio/distill&quot;) RStudioのバージョンは1.2以上であることが求められています。 インストールに成功するとR Markdown...の中のFrom TemplateにDistill Articleが追加されているはずです。 11.5.2 Tufte Handout Tufte Handoutというテンプレートもあります。 Tufte Handout tufteというパッケージをインストールするとテンプレートに追加されます。 11.5.3 rmdformats rmdformatsというテンプレートもあります。 同様に、rmdformatsというパッケージをインストールします。 material readthedown html_clean html_docco 11.5.4 スライド R Markdownから作成できる.htmlファイルのスライドにはioslidesとslidyというものがあります。 ioslides ioslides slidy slidy これらはデフォルトで入っています。 また、reveal.jsという.htmlスライドを作ることもできます。 revealjsというパッケージをインストールするとテンプレートが追加されます。 Presentationの方ではない点に注意。 reveal.js reveal.js 同様にしてxaringanというNARUTOという忍者マンガにインスパイアされたテンプレートを使用することもできます。 xaringan xaringan 11.5.5 ダッシュボード flexdashboardというパッケージを使うとダッシュボードを作ることができます。 パッケージをインストールするとFlex Dashboardというテンプレートが追加されます。 flexdashboard 11.5.6 Microsoft Office R MarkdownからMicrosoft OfficeのWordやPowerPointの形式のファイルを作成することも可能です。 "],
["encoding-r.html", "第12章 Rにおける文字コード* 12.1 なぜ文字化けが起こるのか 12.2 Rスクリプトの文字化け 12.3 データの文字化け 12.4 その他の問題", " 第12章 Rにおける文字コード* Rに限らず文字化けはPCにおいてしばしば起こる問題です。 平たく言ってしまうと、PCでは文字にコードが付与されており、機械がコードを読み取って文字を表示します。 そのコードと文字の対応関係をエンコーディングと呼び、異なるエンコーディングでデータを読み込むと文字化けが起こります。 12.1 なぜ文字化けが起こるのか 12.1.1 エンコーディング 実用上、日本語で文字化けが起こる問題の大半は WindowsではShift-JISあるいはCP932で、 LinuxやMacなどのUNIX系ではUTF-8で エンコーディングしていることに起因しています。 UTF-8のUはunicodeであることからも分かるように、世界で共通の規格として作られているエンコーディング方式になります。 なので、RおよびRStudioでは日本語独自のShift-JISではなくUTF-8を使うようにしたほうがよいでしょう。 12.1.2 RとRStudioにおける問題 RとRStudioで文字化けが起こる問題は大きく2つに分けられます。 RStudioで日本語を含むRスクリプトを開いたとき Rで日本語を含むデータを読み込んだとき 以下では、それぞれの問題の対処法を紹介します。 12.2 Rスクリプトの文字化け Rスクリプトが文字化けしている場合はRStudiで対処します。 例としてUTF-8でエンコードしたRスクリプトとShift-JISでエンコードしたRスクリプトをRStudioで開いてみてください。 （設定を変更していなければ）Windowsの場合は前者が、Linux/Macの人は後者が文字化けしているはずです。 12.2.1 ファイルを開く まず、デフォルトをUTF-8に変更しましょう。 メニューの中のFileにReopen with Encoding...というのがあるので、UTF-8を選択します。 さらにSet as default encoding for source filesにチェックを入れることで今後はUTF-8で表示されます。 UTF-8でエンコードされた方は正常に表示され、Shift-JISでエンコードされた方は文字化けしていることを確認してください。 今後、RStudioで文字化けが起こる場合はデフォルトがUTF-8になっているので、Rスクリプトが他のエンコードのために起こっていることになります。 そのような場合にはReopen with Encoding...で適当なエンコーディングを選択します。 例えば、Shift-JISを選択すると正しく表示されるはずです。 12.2.2 ファイルを保存する 自分で作成したRスクリプトを保存する際にはメニューのFileの中のSave with Encoding...でUTF-8を選択してください。 ここでもUTF-8がデフォルトになるようにチェックを入れておきましょう。 12.3 データの文字化け データが文字化けしているときはRで対処します。 UTF-8でエンコーディングしたデータとShift-JISでエンコーディングしたデータをそれぞれ読み込んでみてください。 やはりWindowsでは前者が、Linux/Macでは後者が文字化けをしているはずです。 read.csv(&quot;data/data_utf8.csv&quot;) read.csv(&quot;data/data_sjis.csv&quot;) ## Error in type.convert.default(data[[i]], as.is = as.is[i], dec = dec, : invalid multibyte string at &#39;&lt;83&gt;C&lt;83&gt;k&#39; 僕はLinuxを使っているので後者が文字化けを起こしてエラーが出ています。 12.3.1 標準関数の場合 標準関数の場合、fileEncodingというオプションでエンコーディングを指定します。 read.csv(&quot;data/data_utf8.csv&quot;, fileEncoding = &quot;utf8&quot;) read.csv(&quot;data/data_sjis.csv&quot;, fileEncoding = &quot;shift-jis&quot;) 12.3.2 tidyverseの場合 tidyverseのreadrの場合はlocaleで指定します。 readrはtidyverseに含まれているので、tidyverseを読み込んだ場合は、別途読み込む必要はありません。 library(tidyverse) read_csv(&quot;data/data_utf8.csv&quot;, locale = locale(encoding = &quot;utf8&quot;)) ## Parsed with column specification: ## cols( ## member = col_character() ## ) read_csv(&quot;data/data_sjis.csv&quot;, locale = locale(encoding = &quot;shift-jis&quot;)) ## Parsed with column specification: ## cols( ## member = col_character() ## ) 12.3.3 エンコーディングを確認する方法 readrのguess_encoding()という関数を使うと、どのようなエンコーディングがされているかを推測します。 guess_encoding(&quot;data/data_utf8.csv&quot;) guess_encoding(&quot;data/data_sjis.csv&quot;) windows-1215というのはCP1215とも呼ばれるエンコーディングで、Shift-JISの親戚のようなものです（きっと）。 12.3.4 もとのデータを見たい場合 しばしばRではなく直接データを見たいときがあります。 そのような場合は、LibreOfficeのCalcというソフトで開くとエンコーディングを指定することができます。 12.3.5 データを保存する場合 データを書き出す場合、UTF-8で行うのが望ましいですが、そうするとWindowsからExcelなどで開いた場合に文字化けしてしまいます。 それを回避するために、readrのwrite_excel_csv()を使うとエクセルで開いても文字化けしません。 12.4 その他の問題 12.4.1 アカウント名が日本語の場合 Windowsでアカウント名が日本語の場合、パスを通すときにエラーが出てくる場合があります。 そのような場合は、 新しいアカウントを作成する。 新しいアカウントを作成し、現在のアカウントの内容を全てコピーして、現在のアカウントを削除する。 OSをクリーンインストールする。 Linux（Ubuntuなど）を使う。 仮想マシン（VMwareやVirtualBox）を使う。 デュアルブートをする。 といった選択肢が考えられます（下に行くほど難易度が高い）。 12.4.2 画像で日本語が文字化けする場合 Macで画像を出力する際に日本語が文字化けすることがあります。 plot()の場合は、 par(family = &quot;HiraKakuProN-W3&quot;) ggplot2の場合は、 theme(base_family = &quot;HiraKakuProN-W3&quot;) とするらしいです（Macは使ったことがないので分かりません）。 quantedaでプロットする際、うまくフォントが指定できない場合があるので、こちらを参考に、extrafont::fonts()でフォント一覧を確認して、適当なものを指定して下さい。 "],
["pipe.html", "第13章 パイプ演算子%&gt;%について* 13.1 基本的な使い方 13.2 データの代入 13.3 左辺の参照 13.4 複数の出力", " 第13章 パイプ演算子%&gt;%について* こいつはtidyverse内のmagrittrというパッケージの機能で、パイプ演算子あるいは単にパイプと呼ばれたりします。 以下のサイトが参考になりました。 R for Data ScienceのPipes magrittrのvignetteの訳 library(tidyverse) library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract 13.1 基本的な使い方 基本的に%&gt;%は左辺の出力を右辺の関数の第1引数にします。 つまり、f %&gt;% gはg(f)と同値です。 ちなみに、RStudioではShift + Ctrl + Mで入力します。 summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## iris %&gt;% summary() ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## これだけだとパイプ演算子のご利益は分かりにくいですが、コードが長くなるにつれてその力を発揮します。 例えば、irisの各品種について各変数の平均と中央値を求めてみます。 パイプ演算子を使うと次のように一行のコードで書くことができます。 iris %&gt;% pivot_longer(-Species, names_to = &quot;var&quot;, values_to = &quot;val&quot;) %&gt;% group_by(var, Species) %&gt;% summarise(mean = mean(val), median = median(val)) iris %&gt;% pivot_longer(-Species, names_to = &quot;var&quot;, values_to = &quot;val&quot;) %&gt;% group_by(var, Species) %&gt;% summarise(mean = mean(val), median = median(val)) %&gt;% knitr::kable() var Species mean median Petal.Length setosa 1.462 1.50 Petal.Length versicolor 4.260 4.35 Petal.Length virginica 5.552 5.55 Petal.Width setosa 0.246 0.20 Petal.Width versicolor 1.326 1.30 Petal.Width virginica 2.026 2.00 Sepal.Length setosa 5.006 5.00 Sepal.Length versicolor 5.936 5.90 Sepal.Length virginica 6.588 6.50 Sepal.Width setosa 3.428 3.40 Sepal.Width versicolor 2.770 2.80 Sepal.Width virginica 2.974 3.00 これをパイプ演算子を使わないと、次のようになります。 summarise(group_by(pivot_longer(iris, -Species, names_to = &quot;var&quot;, values_to = &quot;val&quot;), var, Species), mean = mean(val), median = median(val)) summarise(group_by(pivot_longer(iris, -Species, names_to = &quot;var&quot;, values_to = &quot;val&quot;), var, Species), mean = mean(val), median = median(val)) %&gt;% knitr::kable() var Species mean median Petal.Length setosa 1.462 1.50 Petal.Length versicolor 4.260 4.35 Petal.Length virginica 5.552 5.55 Petal.Width setosa 0.246 0.20 Petal.Width versicolor 1.326 1.30 Petal.Width virginica 2.026 2.00 Sepal.Length setosa 5.006 5.00 Sepal.Length versicolor 5.936 5.90 Sepal.Length virginica 6.588 6.50 Sepal.Width setosa 3.428 3.40 Sepal.Width versicolor 2.770 2.80 Sepal.Width virginica 2.974 3.00 あるいは適当なオブジェクトを作成して次のようにします。 temp &lt;- pivot_longer(iris, -Species, names_to = &quot;var&quot;, values_to = &quot;val&quot;) temp &lt;- group_by(temp, var, Species) temp &lt;- summarise(temp, mean = mean(val), median = median(val)) temp temp &lt;- pivot_longer(iris, -Species, names_to = &quot;var&quot;, values_to = &quot;val&quot;) temp &lt;- group_by(temp, var, Species) temp &lt;- summarise(temp, mean = mean(val), median = median(val)) knitr::kable(temp) var Species mean median Petal.Length setosa 1.462 1.50 Petal.Length versicolor 4.260 4.35 Petal.Length virginica 5.552 5.55 Petal.Width setosa 0.246 0.20 Petal.Width versicolor 1.326 1.30 Petal.Width virginica 2.026 2.00 Sepal.Length setosa 5.006 5.00 Sepal.Length versicolor 5.936 5.90 Sepal.Length virginica 6.588 6.50 Sepal.Width setosa 3.428 3.40 Sepal.Width versicolor 2.770 2.80 Sepal.Width virginica 2.974 3.00 このように考えるとパイプ演算子のご利益は次のようにまとめられます。 処理をする順番に関数が登場するので可読性を高めることができる。 一行でコードを書くことができるので無駄なオブジェクトを作らなくてよい。 13.2 データの代入 データを加工する際、パイプを使うと基本的にはこのようになります。 iris &lt;- iris %&gt;% mutate(species = case_when(Species == &quot;setosa&quot; ~ 0, Species == &quot;versicolor&quot; ~ 1, Species == &quot;virginica&quot; ~ 2)) summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species species ## setosa :50 Min. :0 ## versicolor:50 1st Qu.:0 ## virginica :50 Median :1 ## Mean :1 ## 3rd Qu.:2 ## Max. :2 しかし、左から右に流れるべきと思う場合は次のように書くこともできます。 iris %&gt;% mutate(species = case_when(Species == &quot;setosa&quot; ~ 0, Species == &quot;versicolor&quot; ~ 1, Species == &quot;virginica&quot; ~ 2)) -&gt; iris summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species species ## setosa :50 Min. :0 ## versicolor:50 1st Qu.:0 ## virginica :50 Median :1 ## Mean :1 ## 3rd Qu.:2 ## Max. :2 あるいは%&lt;&gt;%という演算子を使うこともできます。 iris %&lt;&gt;% mutate(species = case_when(Species == &quot;setosa&quot; ~ 0, Species == &quot;versicolor&quot; ~ 1, Species == &quot;virginica&quot; ~ 2)) summary(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species species ## setosa :50 Min. :0 ## versicolor:50 1st Qu.:0 ## virginica :50 Median :1 ## Mean :1 ## 3rd Qu.:2 ## Max. :2 13.3 左辺の参照 基本的にはパイプ演算子の左辺を右辺の第1引数にしますが、.を使うことで任意の引数にすることができます。 例えば、irisでsetosaを除外して回帰分析をしたい場合、第1引数はformulaなので普通はパイプで繋げることはできないが、以下のように書くことができます。 iris %&gt;% filter(Species != &quot;setosa&quot;) %&gt;% lm(Sepal.Length ~ Sepal.Width, data = .) %&gt;% summary() ## ## Call: ## lm(formula = Sepal.Length ~ Sepal.Width, data = .) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.0032 -0.3877 -0.0774 0.3200 1.7381 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.0934 0.4844 6.387 5.70e-09 *** ## Sepal.Width 1.1033 0.1675 6.585 2.27e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5547 on 98 degrees of freedom ## Multiple R-squared: 0.3068, Adjusted R-squared: 0.2997 ## F-statistic: 43.36 on 1 and 98 DF, p-value: 2.27e-09 また、%$%という演算子は右辺において左辺のデータを参照せずに変数名を指定することができます。 したがって、次のように書くこともできます。 iris %&gt;% filter(Species != &quot;setosa&quot;) %$% lm(Sepal.Length ~ Sepal.Width) %&gt;% summary() ## ## Call: ## lm(formula = Sepal.Length ~ Sepal.Width) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.0032 -0.3877 -0.0774 0.3200 1.7381 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.0934 0.4844 6.387 5.70e-09 *** ## Sepal.Width 1.1033 0.1675 6.585 2.27e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5547 on 98 degrees of freedom ## Multiple R-squared: 0.3068, Adjusted R-squared: 0.2997 ## F-statistic: 43.36 on 1 and 98 DF, p-value: 2.27e-09 これは、次のコードと同値です。 iris %&gt;% filter(Species != &quot;setosa&quot;) %&gt;% { lm(.$Sepal.Length ~ .$Sepal.Width) } %&gt;% summary() ## ## Call: ## lm(formula = .$Sepal.Length ~ .$Sepal.Width) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.0032 -0.3877 -0.0774 0.3200 1.7381 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.0934 0.4844 6.387 5.70e-09 *** ## .$Sepal.Width 1.1033 0.1675 6.585 2.27e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5547 on 98 degrees of freedom ## Multiple R-squared: 0.3068, Adjusted R-squared: 0.2997 ## F-statistic: 43.36 on 1 and 98 DF, p-value: 2.27e-09 13.4 複数の出力 .を使うことで複数の出力を行うことも可能です。 iris$Sepal.Length %&gt;% { mean(.) %&gt;% print() median(.) %&gt;% print() var(.) %&gt;% print() } ## [1] 5.843333 ## [1] 5.8 ## [1] 0.6856935 $T&gt;$という演算子を使うと右辺は評価されるが、返り値は左辺のままになります。 例えば、plot()に流すことで図を出力しつつ、irisをsummary()にも流すことができます。 iris %T&gt;% plot() %&gt;% summary() ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species species ## setosa :50 Min. :0 ## versicolor:50 1st Qu.:0 ## virginica :50 Median :1 ## Mean :1 ## 3rd Qu.:2 ## Max. :2 これは、以下のコードと同値です。 iris %&gt;% { plot(.) summary(.) } ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species species ## setosa :50 Min. :0 ## versicolor:50 1st Qu.:0 ## virginica :50 Median :1 ## Mean :1 ## 3rd Qu.:2 ## Max. :2 "],
["environment.html", "動作環境", " 動作環境 sessionInfo() ## R version 3.6.3 (2020-02-29) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.4 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] magrittr_1.5 haven_2.2.0 readxl_1.3.1 knitr_1.28 ## [5] forcats_0.5.0 stringr_1.4.0 dplyr_0.8.5 purrr_0.3.4 ## [9] readr_1.3.1 tidyr_1.0.2 tibble_3.0.0 ggplot2_3.3.0 ## [13] tidyverse_1.3.0 ## ## loaded via a namespace (and not attached): ## [1] tidyselect_1.0.0 xfun_0.13 lattice_0.20-41 colorspace_1.4-1 ## [5] vctrs_0.2.4 generics_0.0.2 htmltools_0.4.0 yaml_2.2.1 ## [9] rlang_0.4.5 pillar_1.4.3 withr_2.1.2 glue_1.4.0 ## [13] DBI_1.1.0 dbplyr_1.4.3 modelr_0.1.6 lifecycle_0.2.0 ## [17] munsell_0.5.0 gtable_0.3.0 cellranger_1.1.0 rvest_0.3.5 ## [21] evaluate_0.14 fansi_0.4.1 highr_0.8 broom_0.5.5 ## [25] Rcpp_1.0.4.6 backports_1.1.6 scales_1.1.0 jsonlite_1.6.1 ## [29] fs_1.4.1 hms_0.5.3 digest_0.6.25 stringi_1.4.6 ## [33] bookdown_0.18 grid_3.6.3 cli_2.0.2 tools_3.6.3 ## [37] crayon_1.3.4 pkgconfig_2.0.3 ellipsis_0.3.0 xml2_1.3.1 ## [41] reprex_0.3.0 lubridate_1.7.8 assertthat_0.2.1 rmarkdown_2.1 ## [45] httr_1.4.1 rstudioapi_0.11 R6_2.4.1 nlme_3.1-144 ## [49] compiler_3.6.3 "],
["references.html", "参考文献", " 参考文献 "]
]
