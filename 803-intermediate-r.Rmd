# Rプログラミング応用* {#inter-r}

Rによる、より高度な作業のために

- 代表的な[オブジェクトのクラス]
- オリジナルの[関数の作成]
- [ループ]や[条件分岐]

などを学びます。

## オブジェクトのクラス

オブジェクトの種類を**クラス**と呼びます。
`class()`にオブジェクトを入力するとクラスが分かります。

最も使われるのは数値 ()numeric, real) です。

```{r}
class(1)
```

厳密には数値と整数 (integer) は異なりますが、気にしないといけない局面は少ないと思います。

```{r}
class(2L)
```

他には、文字列 (character) や

```{r}
class("Hello, World.")
```

論理値 (logical) などもあります。

```{r}
class(TRUE)
```

論理値は主に条件式が満たされるかどうかを示します。

```{r}
1 == 1
0 > 2
```

ちなみに、`TRUE`は数値としての`1`、`FALSE`は`0`にもなります。

```{r}
TRUE + 1
FALSE * 2
```

また、因子型 (factor) と呼ばれるクラスもあります。
カテゴリカル変数と言ったほうが分かりやすいかもしれません。

```{r}
x <- factor(1)
x
class(x)
```

`X`の中身は`1`ですが、数値ではなくカテゴリーになっているので、数値として操作することはできません。

```{r, error=TRUE}
x + 1
```

Rではベクトルには特別なクラスは付与されていません。
ベクトルは`c()`に中身を入力して作成します。

```{r}
x <- c(1,3,5)
x
```

行列 (matrix) はクラスとして存在します。

```{r}
x <- matrix(c(1,3,5,7), 2, 2)
x
class(x)
```

他に、データフレーム (data.frame) やリスト (list) などもあります。

クラスを確認するときは、`is.*()`の形をとる関数を使います。

```{r}
is.numeric(1)
is.character(1)
```

クラスを変更するときは、`as.*()`のような関数を使います。

```{r}
as.factor(1)
as.character(1)
```

- 必ずしも全てのクラスが任意のクラスに変換できるわけではありません（例えば、文字列から数値など）。

## 関数の作成

Rで関数を自作する際は`function(){}`という関数を使います。

- `()`の中に入力引数を記述します。
- `{}`の中に処理内容を記述し、最後に`return()`で出力引数を指定します。

例えば、数値ベクトルを入力引数として、平均と標準偏差を出力引数とする関数を作成します。

```{r}
mean_sd <- function(x) { # 入力引数の名前をxとしておきます。
  mean.x <- mean(x) # 平均を計算します。
  sd.x <- sd(x) # 標準偏差を計算します。
  return(c(mean.x, sd.x)) # 出力引数を指定します。
}
```

実際に実行してみます。

```{r}
x <- rnorm(100)
mean_sd(x)
```

## ループ

**ループ**とは同一の処理を複数回実行することを指します。
例えば、100個の標準正規分布に従う乱数の平均を5回求める処理は次のようになります。

```{r}
for (i in 1:5) {
  print(mean(rnorm(100)))
}
```

`for`ループとは`()`の中の`in`のあとのベクトルの第1要素から順番に`i`に代入して繰り返しています。
そのことは、次の例から解ると思います。

```{r}
head(letters)
```

- `letters`とはアルファベットのベクトルです。

```{r}
for (i in head(letters)) {
  print(i)
}
```

- `for`ループとは別に、特定の条件が満たされるまで繰り返される`while`ループもあります。

ループ処理の結果を格納するには少しテクニックが必要です。
100個の乱数の平均を5回取ったものを`x`として保存したいとします。

まず、`x`を`NULL`オブジェクトとして作成します。

```{r}
x <- NULL
x
```

- `NULL`とは空っぽのオブジェクト（0という数値や空白という文字ではない）です。

先程のループ処理の中で、計算した平均を`c()`で`x`にくっつけていきます。

```{r}
for (i in 1:5) {
  x <- c(x, mean(rnorm(100)))
}
x
```

無事、5個の平均値が`x`に保存されていることがわかります。

実際に`for`ループの中で何が起こっているかは、次のコードで解ると思います。

```{r}
x <- NULL
for (i in 1:5) {
  x <- c(x, mean(rnorm(100)))
  print(x)
}
```

- ループが一周するたびに、前回の`x`に新しい要素が付け加わり、新しい`x`として保存されています。

`NULL`オブジェクトを使ったループ結果の保存でよくあるミスは、やり直す際に`NULL`でリセットするのを忘れることです。
例えば、同じコードをもう一度実行しましょう。

```{r}
for (i in 1:5) {
  x <- c(x, mean(rnorm(100)))
}
x
```

- `x`に10個の平均値が入っています。

このようなミスを避ける方法の一つは、全体を関数として作成することです。

```{r}
multi_mean <- function() {
  x <- NULL
  for (i in 1:5) {
    x <- c(x, mean(rnorm(100)))
  }
  return(x)
}
x <- multi_mean()
x
```

## 条件分岐

**条件分岐**とは、特定の条件の場合に特定の動作を行うようにすることです。
例えば、正の場合`positive`、負の場合`negative`と出力するコマンドは次のようになります。

```{r}
x <- rnorm(1)
if (x > 0) {
  print("positive")
} else {
  print("negative")
}
print(x)
```

- `if(){}`の`()`の中に条件式を書き、`{}`の中に処理内容を書きます。
- それ以外の条件は`else`で示します。

条件式は3つ以上でも構いません。

```{r}
x <- rnorm(1)
if (x > -0.5) {
  print("x is less than -0.5.")
} else if (x >= -0.5 & x <= 0.5) {
  print("x is between -0.5 and 0.5.")
} else {
  print("x is more than 0.5.ー")
}
print(x)
```

- `&`は「かつ」を意味します。
- 「または」は`|`を使います。
- `>=`は $\geq$ を意味します。
- 「同じ値である」は`==`を使います（`=`ではない点に注意）。

## 練習問題

### フィボナッチ数列

フィボナッチ数列とは以下の条件を満たす数列です。

$$
\begin{aligned}
  F_0 &= 0 \\
  F_1 &= 1 \\
  F_{n} &= F_{n-1} + F_{n-2} \quad n \geq 2
\end{aligned}
$$

例えば、

$$
\begin{aligned}
  F_2 = 1, F_3 = 2, F_4 = 3, F_5 = 5, F_6 = 8,\ldots
\end{aligned}
$$

となります。

フィボナッチ数列の第$n$項を（解析解を使わずに）求める関数を作成してみて下さい。

また、$F_n \geq m$となるような$n$を求める関数を作成してみて下さい。

### モンテカルロ・シミュレーション

モンテカルロ・シミュレーション（モンテカルロ法）とは乱数を用いて近似解を求める手法です。

例えば、円周率$\pi$の近似解は以下のように求めることができます。

1. 0以上1未満の一様分布から$n$個の乱数$x_i$と$n$個の乱数$y_i$を発生させます ($i = 1,2,\ldots,n$) 。
1. 原点と$(x_i,y_i)$の距離が1以下である回数を計算し$n_1$とします。
1. 円周率の近似解として$\hat{\pi} = 4 \times n_1/n$を得ます。

モンテカルロ・シミュレーションによる円周率の近似解を求める関数を作成してみて下さい。

また、モンテカルロ・シミュレーションによる円周率の近似解を$m$回求めて、その平均値や標準偏差が$n$によってどのように変化するか検討してみて下さい。